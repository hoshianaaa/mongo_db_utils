#!/bin/bash
# MongoDB便利コマンド集 (mongodb_commands.sh)

# 実行ログを出力する関数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# 使用方法を表示
show_usage() {
    echo "使用方法: $0 [command]"
    echo ""
    echo "利用可能なコマンド:"
    echo "  import    - CSVファイルをMongoDBにインポート"
    echo "  export    - MongoDBのデータをCSV/JSONにエクスポート"
    echo "  backup    - データベースのバックアップを作成"
    echo "  restore   - バックアップからデータベースを復元"
    echo "  stats     - データベースとコレクションの統計情報を表示"
    echo "  query     - 対話的にクエリを実行"
    echo "  help      - このヘルプメッセージを表示"
}

# CSVのインポート
import_csv() {
    if [ -z "$1" ]; then
        log "CSVファイルを指定してください。"
        echo "使用方法: $0 import <csvファイル> <データベース名> <コレクション名>"
        return 1
    fi
    
    CSV_FILE="$1"
    DB_NAME="${2:-sampledb}"
    COLLECTION="${3:-$(basename "$CSV_FILE" .csv)}"
    
    log "CSVファイル '$CSV_FILE' を $DB_NAME.$COLLECTION にインポートしています..."
    
    mongoimport --db "$DB_NAME" --collection "$COLLECTION" --type csv --headerline --file "$CSV_FILE"
    
    log "インポートが完了しました。"
}

# データのエクスポート
export_data() {
    DB_NAME="${1:-sampledb}"
    COLLECTION="${2:-users}"
    FORMAT="${3:-csv}"
    FIELDS="${4:-name,age,email,active}"
    OUTPUT_FILE="${5:-${COLLECTION}_export.${FORMAT}}"
    
    log "$DB_NAME.$COLLECTION を $FORMAT 形式でエクスポートしています..."
    
    if [ "$FORMAT" = "csv" ]; then
        mongoexport --db "$DB_NAME" --collection "$COLLECTION" --type="$FORMAT" --fields="$FIELDS" --out="$OUTPUT_FILE"
    else
        mongoexport --db "$DB_NAME" --collection "$COLLECTION" --out="$OUTPUT_FILE"
    fi
    
    log "エクスポートが完了しました: $OUTPUT_FILE"
}

# データベースのバックアップ
backup_database() {
    DB_NAME="${1:-sampledb}"
    BACKUP_DIR="${2:-./mongodb_backup}"
    
    # バックアップディレクトリを作成
    mkdir -p "$BACKUP_DIR"
    
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_PATH="$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}"
    
    log "データベース '$DB_NAME' をバックアップしています..."
    
    mongodump --db "$DB_NAME" --out="$BACKUP_PATH"
    
    log "バックアップが完了しました: $BACKUP_PATH"
}

# データベースの復元
restore_database() {
    BACKUP_PATH="$1"
    
    if [ -z "$BACKUP_PATH" ]; then
        log "バックアップパスを指定してください。"
        echo "使用方法: $0 restore <バックアップディレクトリパス>"
        return 1
    fi
    
    log "バックアップ '$BACKUP_PATH' からデータベースを復元しています..."
    
    mongorestore "$BACKUP_PATH"
    
    log "復元が完了しました。"
}

# 統計情報の表示
show_stats() {
    log "MongoDBの統計情報を表示します..."
    
    mongosh --eval '
    // データベース一覧
    print("=== データベース統計 ===");
    db.adminCommand("listDatabases").databases.forEach(function(d) {
        print(" - " + d.name + ":");
        var stats = db.getSiblingDB(d.name).stats();
        print("   * サイズ: " + (stats.dataSize / (1024*1024)).toFixed(2) + " MB");
        print("   * インデックスサイズ: " + (stats.indexSize / (1024*1024)).toFixed(2) + " MB");
        print("   * コレクション数: " + stats.collections);
        print("");
        
        // 各データベースの大きなコレクション
        var collections = db.getSiblingDB(d.name).getCollectionNames();
        if (collections.length > 0) {
            print("   大きなコレクション (上位3):");
            var collStats = [];
            collections.forEach(function(c) {
                try {
                    var cs = db.getSiblingDB(d.name)[c].stats();
                    collStats.push({name: c, size: cs.size, count: cs.count});
                } catch (e) {
                    // システムコレクションなどでエラーが発生する場合があるため無視
                }
            });
            
            // サイズでソートして上位3件表示
            collStats.sort(function(a, b) { return b.size - a.size; });
            for (var i = 0; i < Math.min(3, collStats.length); i++) {
                var cs = collStats[i];
                print("    * " + cs.name + ": " + (cs.size / (1024*1024)).toFixed(2) + " MB (" + cs.count + " documents)");
            }
        }
        print("");
    });
    
    // サーバーの状態
    print("=== サーバー状態 ===");
    var serverStatus = db.serverStatus();
    print(" - 接続数: " + serverStatus.connections.current);
    print(" - アップタイム: " + (serverStatus.uptime / 3600).toFixed(2) + " 時間");
    print(" - メモリ使用: " + (serverStatus.mem.resident / 1024).toFixed(2) + " GB");
    '
    
    log "統計情報の表示が完了しました。"
}

# 対話的なクエリ実行
interactive_query() {
    log "対話的なクエリモードを開始します..."
    log "データベースとコレクションを選択してください。"
    
    read -p "データベース名 [sampledb]: " DB_NAME
    DB_NAME=${DB_NAME:-sampledb}
    
    # コレクション一覧を取得
    COLLECTIONS=$(mongosh --quiet --eval "db.getSiblingDB('$DB_NAME').getCollectionNames().join('\n')")
    
    echo "利用可能なコレクション:"
    echo "$COLLECTIONS" | nl
    
    read -p "コレクション名 [users]: " COLLECTION
    COLLECTION=${COLLECTION:-users}
    
    # クエリメニュー
    while true; do
        echo ""
        echo "=== クエリメニュー ($DB_NAME.$COLLECTION) ==="
        echo "1. 全件表示"
        echo "2. 条件検索"
        echo "3. 件数カウント"
        echo "4. フィールド一覧表示"
        echo "5. ソート"
        echo "6. 集計"
        echo "7. データベース/コレクションを変更"
        echo "0. 終了"
        echo ""
        
        read -p "選択してください: " CHOICE
        
        case "$CHOICE" in
            1)
                read -p "最大表示件数 [10]: " LIMIT
                LIMIT=${LIMIT:-10}
                mongosh --quiet --eval "db.getSiblingDB('$DB_NAME').$COLLECTION.find().limit($LIMIT).forEach(printjson)"
                ;;
            2)
                echo "条件式の例: { age: { \$gt: 30 } } または { name: \"田中太郎\" }"
                read -p "条件式: " QUERY
                mongosh --quiet --eval "db.getSiblingDB('$DB_NAME').$COLLECTION.find($QUERY).forEach(printjson)"
                ;;
            3)
                read -p "条件式 (空欄で全件): " QUERY
                QUERY=${QUERY:-"{}"}
                mongosh --quiet --eval "print(db.getSiblingDB('$DB_NAME').$COLLECTION.countDocuments($QUERY) + ' 件')"
                ;;
            4)
                echo "最初のドキュメントからフィールド一覧を表示します..."
                mongosh --quiet --eval "var doc = db.getSiblingDB('$DB_NAME').$COLLECTION.findOne(); if(doc) { print('フィールド一覧:'); Object.keys(doc).forEach(function(k) { print(' - ' + k + ': ' + typeof doc[k]); }); } else { print('ドキュメントが見つかりません'); }"
                ;;
            5)
                echo "ソートフィールドの例: { age: 1 }（昇順）または { age: -1 }（降順）"
                read -p "ソートフィールド: " SORT
                read -p "最大表示件数 [10]: " LIMIT
                LIMIT=${LIMIT:-10}
                mongosh --quiet --eval "db.getSiblingDB('$DB_NAME').$COLLECTION.find().sort($SORT).limit($LIMIT).forEach(printjson)"
                ;;
            6)
                echo "集計パイプラインの例: [{ \$group: { _id: \"\$active\", count: { \$sum: 1 } } }]"
                read -p "集計パイプライン: " PIPELINE
                mongosh --quiet --eval "db.getSiblingDB('$DB_NAME').$COLLECTION.aggregate($PIPELINE).forEach(printjson)"
                ;;
            7)
                read -p "新しいデータベース名: " DB_NAME
                
                # コレクション一覧を取得
                COLLECTIONS=$(mongosh --quiet --eval "db.getSiblingDB('$DB_NAME').getCollectionNames().join('\n')")
                
                echo "利用可能なコレクション:"
                echo "$COLLECTIONS" | nl
                
                read -p "新しいコレクション名: " COLLECTION
                ;;
            0)
                log "対話的なクエリモードを終了します。"
                return 0
                ;;
            *)
                echo "無効な選択です。もう一度選択してください。"
                ;;
        esac
    done
}

# メイン処理
if [ $# -eq 0 ]; then
    show_usage
    exit 1
fi

case "$1" in
    import)
        shift
        import_csv "$@"
        ;;
    export)
        shift
        export_data "$@"
        ;;
    backup)
        shift
        backup_database "$@"
        ;;
    restore)
        shift
        restore_database "$@"
        ;;
    stats)
        show_stats
        ;;
    query)
        interactive_query
        ;;
    help)
        show_usage
        ;;
    *)
        log "不明なオプション: $1"
        show_usage
        exit 1
        ;;
esac

exit 0
